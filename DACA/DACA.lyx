#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{algorithm}
\usepackage{algpseudocode}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Analysis of Computer Algorithms
\end_layout

\begin_layout Chapter
Basic Tools on Designing Algorithms
\end_layout

\begin_layout Section
Algorithms
\end_layout

\begin_layout Standard
An algorithm is a finite set of instructions that when followed on certain
 set of values (the input), halts to produce a desired set of values (the
 output).
 All algorithms follow some criteria - 
\end_layout

\begin_layout Itemize
It should have an input set (zero or more values)
\end_layout

\begin_layout Itemize
It should have an output set (one or more values)
\end_layout

\begin_layout Itemize
Each instruction has to be precisely clear.
 No ambiguity.
\end_layout

\begin_layout Itemize
The algorithm should stop after a finite number of steps.
\end_layout

\begin_layout Itemize
The steps should be simple enough.
\end_layout

\begin_layout Subsection
Computational Procedure
\end_layout

\begin_layout Standard
A finite set of instructions that is clear and simple/effective (follows
 
\begin_inset Formula $3,5$
\end_inset

) but which might/might not stop after a finite number of steps is a computation
al procedure.
 An example is a bash console, or an operating system.
\end_layout

\begin_layout Subsection
Program
\end_layout

\begin_layout Standard
What is a program? It is just the algorithm, written in a programming language
 which has a specific syntax.
\end_layout

\begin_layout Section
Algorithm Specification
\end_layout

\begin_layout Standard
An algorithm can be described in multiple ways.
 We can use a natural language like English, or we could use a real programming
 language like Python or C.
 However, what is generally preferred is a mix of the two.
 We call this convention 
\series bold
pseudocode
\series default
.
 Pseudocode is just like writing English, except the fact that instructions
 are quite precise and definite.
 Some functions or keywords like 
\series bold
while
\series default
, 
\series bold
for
\series default
 etc.
 are directly borrowed from simple programming languages so that the reader
 is at ease with whatever he/she knows about programming languages, and
 doesn't need to learn something new to learn algorithms.
\end_layout

\begin_layout Enumerate
Comments are written down as
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Comment{This is where the comment occurs.}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Variable assignment is done as
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $x=5$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In general, the common relational operators are
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $x==5$ 
\backslash
Comment{Is $x$ equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x>5$ 
\backslash
Comment{Is $x$ greater than $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x<5$ 
\backslash
Comment{Is $x$ less than $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x>=5$ 
\backslash
Comment{Is $x$ greater than or equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x<=5$ 
\backslash
Comment{Is $x$ less than or equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x
\backslash
neq 5$ 
\backslash
Comment{Is $x$ not equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The answers to these relational operators are boolean, i.e.
 they can be either true or false.
 We will show a true value by 
\series bold
True
\series default
 and a false value by 
\series bold
False
\series default
.
\end_layout

\end_deeper
\begin_layout Enumerate
The logical operators 
\series bold
and
\series default
, 
\series bold
or
\series default
, 
\series bold
not
\series default
 and their derivatives are used as such.
\end_layout

\begin_layout Enumerate
Most of the loops are either 
\series bold
for
\series default
 or 
\series bold
while
\series default
 in nature.
\end_layout

\begin_layout Enumerate

\series bold
for
\series default
 loops use the following syntax - (Its similar to VB)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
For{$i=$ start 
\backslash
textbf{to} end 
\backslash
textbf{step} $1$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State statement(s)
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
while 
\series default
loops use the following syntax -
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
While{condition}
\end_layout

\begin_layout Plain Layout

	
\backslash
State statement(s)
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Performance Analysis
\end_layout

\begin_layout Subsection
Space Complexity
\end_layout

\begin_layout Standard
This is the amount of memory an algorithm needs to halt and produce a correct
 output.
\end_layout

\begin_layout Subsection
Time Complexity
\end_layout

\begin_layout Standard
This is the amount of time an algorithm requires to complete.
\end_layout

\begin_layout Subsection
Types of Analysis
\end_layout

\begin_layout Standard
Broadly, performance analysis can be divided into two parts - 
\end_layout

\begin_layout Itemize
Apriori, theoretical estimates
\end_layout

\begin_layout Itemize
Posteriori, practical analysis
\end_layout

\begin_layout Subsection*
Apriori Analysis
\end_layout

\begin_layout Standard
In apriori analysis, we are given the input i.e.
 as set of numbers and we estimate the time or space complexity in terms
 of the input.
 For example, let us find out the time complexity of the following algorithm
 which just adds all the numbers from 
\begin_inset Formula $1$
\end_inset

 to the input.
 Let the input be 
\begin_inset Formula $n$
\end_inset

, then a way to find the time complexity is to actually find the number
 of instructions executed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 
\backslash
caption{Sum of numbers from $1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{sum-upto-n}{$n$}%1
\end_layout

\begin_layout Plain Layout

	
\backslash
State sum = $0$%2
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=1$ to $n$}%3
\end_layout

\begin_layout Plain Layout

		
\backslash
State sum = sum + $i$%4
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor%5
\end_layout

\begin_layout Plain Layout

	
\backslash
State
\backslash
textbf{return} sum%6
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure%7
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Step 
\begin_inset Formula $2$
\end_inset

 takes 
\begin_inset Formula $1$
\end_inset

 instruction, step 
\begin_inset Formula $3$
\end_inset

 runs for 
\begin_inset Formula $n+1$
\end_inset

 instructions because the 
\series bold
for
\series default
 loop starts at 
\begin_inset Formula $i=1$
\end_inset

 and goes on till 
\begin_inset Formula $i=n$
\end_inset

, but in the next iteration finds out that 
\begin_inset Formula $i=n+1$
\end_inset

 which was not intended.
 Every 
\series bold
for 
\series default
loop is like that in real programming languages.
 Similarly step 
\begin_inset Formula $4$
\end_inset

 and 
\begin_inset Formula $5$
\end_inset

 run for 
\begin_inset Formula $n$
\end_inset

 times, and step 
\begin_inset Formula $6$
\end_inset

 takes 
\begin_inset Formula $1$
\end_inset

 instruction.
 So total number of instructions, say 
\begin_inset Formula $T(n)$
\end_inset

 is 
\begin_inset Formula 
\[
T(n)=1+(n+1)+2n+1=3n+3
\]

\end_inset


\end_layout

\begin_layout Standard
So, number of instructions is linear in terms of input.
\end_layout

\begin_layout Quote
In general, apriori analysis of time complexity means finding out the instructio
n count, since that is the same for every machine the algorithm runs on,
 and is a valid theoretical estimate of the actual running time.
\end_layout

\begin_layout Standard
For doing apriori analysis of space complexity, if the data used in the
 algorithm is all of the same type, i.e.
 all numbers or all characters etc., then we find out the capacity of the
 variables used.
 That is the general idea.
\end_layout

\begin_layout Subsection*
Priori Analysis
\end_layout

\begin_layout Standard
It refers to the actual practical running time for the given algorithm,
 and it strictly depends on the system.
 Better systems mean lesser running times and vice versa holds.
\end_layout

\begin_layout Subsection
Asymptotic Notations
\end_layout

\begin_layout Standard
These are the notations which allow us to make meaningful approximations
 about the behavior of an algorithm, i.e.
 how much time it might take and how much space it might take.
 Since these are theoretical notations, they are used to analyse mathematically
 the time and space needed by an algorithm, and hence are useful for apriori
 analysis.
\end_layout

\begin_layout Standard
There is a reason why these notations are called 
\series bold
asymptotic
\series default
.
 This is because the calculations done using these notations represent how
 the actual algorithm behaves for large inputs, even though it may not be
 feasible to run for these large inputs.
 Let us mathematically see these notations -
\end_layout

\begin_layout Subsubsection
Big Oh (
\begin_inset Formula $O$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=O(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(n)\leq c\cdot g(n)\mbox{ for all \ensuremath{n,n\geq n_{0}}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=O(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Big Omega (
\begin_inset Formula $\Omega$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\Omega(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that 
\begin_inset Formula 
\[
f(n)\geq c\cdot g(n)\mbox{ for all \ensuremath{n,n\geq n_{0}}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=\Omega(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Big Theta (
\begin_inset Formula $\Theta$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\Theta(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c_{1},c_{2},n_{0}$
\end_inset

 such that 
\begin_inset Formula 
\[
c_{1}g(n)\leq f(n)\leq c_{2}g(n)\mbox{ for all \ensuremath{n,n\geq0}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=O(g(n))$
\end_inset

 and 
\begin_inset Formula $f(n)=\Omega(g(n))$
\end_inset

 then 
\begin_inset Formula $f(n)=\Theta(g(n))$
\end_inset

.
\end_layout

\begin_layout Corollary
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=\Theta(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Little Oh (
\begin_inset Formula $o$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=o(g(n))$
\end_inset

 if and only if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}=0
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Little Omega (
\begin_inset Formula $\omega$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\omega(g(n))$
\end_inset

 if and only if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{g(n)}{f(n)}=0
\]

\end_inset


\end_layout

\begin_layout Section
Randomized Algorithms
\end_layout

\begin_layout Subsection
Basics
\end_layout

\begin_layout Standard
In probability, we conduct experiments and analyze their outcomes.
 An 
\series bold
experiment 
\series default
is a procedure that has some definite outcomes, or
\series bold
 events
\series default
.
 For example, tossing a coin is an experiment whose outcomes are either
 heads, or tails.
 Each possible outcome is called a 
\series bold
sample point
\series default
.
 Sample points constitute the 
\series bold
sample space
\series default
, which is simply the set of all possible outcomes for the given experiment,
 whether discrete or continuous.
\end_layout

\begin_layout Subsubsection*
What is probability?
\end_layout

\begin_layout Standard
Suppose the sample space of an event/experiment 
\begin_inset Formula $E$
\end_inset

 is denoted by 
\begin_inset Formula $S$
\end_inset

.
 Then if any outcome is the event 
\begin_inset Formula $X$
\end_inset

, then the probability of that outcome 
\begin_inset Formula $X$
\end_inset

 is defined as 
\begin_inset Formula 
\[
P(X)=\frac{n(X)}{n(S)}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $n(X)$
\end_inset

 are the number of elements that correspond to the outcome 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $n(S)$
\end_inset

 are the number of elements that correspond to the sample space (basically
 the size of the sample space).
\end_layout

\begin_layout Standard
Sum of probabilities of all the outcomes is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Conditional Probability
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $E_{1}$
\end_inset

and 
\begin_inset Formula $E_{2}$
\end_inset

 be any two events of an experiment.
 The 
\series bold
conditional probability 
\series default
of 
\begin_inset Formula $E_{1}$
\end_inset

 occurring given 
\begin_inset Formula $E_{2}$
\end_inset

 has occurred is denoted by 
\begin_inset Formula $P(E_{1}|E_{2})$
\end_inset

 and is given as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(E_{1}|E_{2})=\frac{P(E_{1}\cap E_{2})}{P(E_{2})}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Independence
\end_layout

\begin_layout Standard
Two events 
\begin_inset Formula $E_{1}$
\end_inset

and 
\begin_inset Formula $E_{2}$
\end_inset

 are said to be independent if 
\begin_inset Formula $P(E_{1}\cap E_{2})=P(E_{1})\cdot P(E_{2})$
\end_inset

 i.e.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(E_{1}|E_{2})=P(E_{1})
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Random Variable
\end_layout

\begin_layout Standard
A random variable on the sample space 
\begin_inset Formula $S$
\end_inset

 of an experiment is a function that maps 
\begin_inset Formula $S$
\end_inset

 to the set of real numbers.
 Hence, if 
\begin_inset Formula $X$
\end_inset

 is the random variable, then 
\begin_inset Formula $X(s)$
\end_inset

 is the image of 
\begin_inset Formula $s\in S$
\end_inset

 such that 
\begin_inset Formula $X(s)\in\mathbf{R}$
\end_inset

.
 If the range of 
\begin_inset Formula $X$
\end_inset

 is finite and countable, then we say that 
\begin_inset Formula $X$
\end_inset

 is a discrete randome variable.
\end_layout

\begin_layout Subsubsection*
Expected Value
\end_layout

\begin_layout Standard
The expected value or the mean of any random variable 
\begin_inset Formula $X$
\end_inset

 is defined to be
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
E[X]={\displaystyle \sum_{i=1}^{n}}P(s_{i})\cdot X(s_{i})\mbox{ for all \ensuremath{s_{i}\in S}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Probability Distribution
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $X$
\end_inset

 is a discrete random variable such that its range is 
\begin_inset Formula $\{r_{1},r_{2},...,r_{m}\}$
\end_inset

 then the probability distribution of 
\begin_inset Formula $X$
\end_inset

 is the sequence 
\begin_inset Formula $\{P(X=r_{1}),P(X=r_{2}),...,P(X=r_{m})\}$
\end_inset

.
 Sum over the entire distribution is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Binomial Distribution
\end_layout

\begin_layout Standard
A Bernoulli trial is an experiment that has two possible outcomes, i.e.
 success and failure.
 So, if there are 
\begin_inset Formula $n$
\end_inset

 trials, then the sample space has 
\begin_inset Formula $2^{n}$
\end_inset

 sample points.
 Let 
\begin_inset Formula $X$
\end_inset

 be a random variable which is the number of successes in the 
\begin_inset Formula $n$
\end_inset

 trials.
 Then 
\begin_inset Formula 
\[
P(X=i)=\bigg(\begin{array}{c}
n\\
i
\end{array}\bigg)\cdot p^{i}(1-p)^{n-i}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $p$
\end_inset

 is the probability of success.
\end_layout

\begin_layout Standard
It comes out, that the expected value of 
\begin_inset Formula $X$
\end_inset

 is 
\begin_inset Formula $np$
\end_inset

.
\end_layout

\begin_layout Subsection
Description of Randomized Algorithms
\end_layout

\begin_layout Standard
Randomized algorithms have steps that rely on random choices.
 Those choices are generated when the algorithm is running with the help
 of randomizers (like random number generators).
 Randomized algorithms can be of two types -
\end_layout

\begin_layout Enumerate
Monte Carlo type
\end_layout

\begin_layout Enumerate
Las Vegas type
\end_layout

\begin_layout Subsection
Monte Carlo Randomized Algorithms
\end_layout

\begin_layout Standard
Outputs of these algorithms vary for each run, however the run time is nearly
 the same for each run.
\end_layout

\begin_layout Subsection
Las Vegas Randomized Algorithms
\end_layout

\begin_layout Standard
Run time is a random variable that depends on the random choices made during
 execution.
\end_layout

\begin_layout Subsection
Idea
\end_layout

\begin_layout Standard
A randomized algorithm can be seen as a family of algorithms.
 For any input, some of these algorithms may run for longer time or may
 give wrong outputs.
 We design the algorithm, however, such that the fraction of such bad instances
 is very less.
 If we can design the algorithm to have a large fraction of correct instances,
 then we can be sure that in general, any run will give a correct output.
\end_layout

\begin_layout Chapter
Divide and Conquer
\end_layout

\begin_layout Section
General Way
\end_layout

\begin_layout Standard
Divide and Conquer is a problem solving strategy in which we split the inputs
 into 
\begin_inset Formula $k$
\end_inset

 different parts, yielding 
\begin_inset Formula $k$
\end_inset

 subproblems.
 Then each of the subproblem is individually solved, using the general algorithm
 and results are combined together.
 The approach is a bit recursive.
\end_layout

\begin_layout Subsection*
Control Abstraction
\end_layout

\begin_layout Standard
Control Abstraction refers to a procedure whose flow of control is clear
 but whose primary operations are specified by other procedures whose precise
 meanings are left undefined.
 We can write divide and conquer algorithms using control abstractions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/divide-conquer.svg
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Time Complexity
\end_layout

\begin_layout Standard
In general, the time complexity of a divide and conquer algorithm which
 at each step, divides the input 
\begin_inset Formula $n$
\end_inset

 given to it into 
\begin_inset Formula $a$
\end_inset

 parts of size 
\begin_inset Formula $n/b$
\end_inset

 can be suitably written as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
T(1) & n=1\\
aT(n/b)+f(n) & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $a,b$
\end_inset

 are known constants.
 This is a recurrence relation, which can be solved using the substitution
 method (just substitute 
\begin_inset Formula $T(n/b)$
\end_inset

 over and over again until it disappears).
 A rigorous analysis gives us the solution to this relation (master method).
\end_layout

\begin_layout Section
Application to Binary Search
\end_layout

\begin_layout Standard
Consider a list of elements as input, which are already sorted in non decreasing
 order.
 We need to find whether a given element 
\begin_inset Formula $x$
\end_inset

 is present in the list or not.
 A simple way would be to go through the list checking one element at a
 time, until the list is finished.
 However that would take 
\begin_inset Formula $T(n)\leq n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the number of elements, so that is 
\begin_inset Formula $O(n)$
\end_inset

 in nature.
\end_layout

\begin_layout Standard
However, there is another faster way to find out this, exploiting the fact
 that the list is sorted.
 If we start from the middle of the list, (say the middle element is 
\begin_inset Formula $y$
\end_inset

) and compare it to 
\begin_inset Formula $x$
\end_inset

, then
\end_layout

\begin_layout Itemize
\begin_inset Formula $x>y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 lies to the end of list, i.e.
 towards the end with the largest element.
\end_layout

\begin_layout Itemize
\begin_inset Formula $x<y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 lies towards the end with the smallest element.
\end_layout

\begin_layout Itemize
\begin_inset Formula $x=y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 is the middle element, so yes, it exists.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Binary Search}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Binary-Search}{$a,l,r,x$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$r==l$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$x==a[l]$} 
\backslash
Return $l$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: 
\backslash
Return $-1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State mid = $
\backslash
displaystyle{
\backslash
lfloor {l+r 
\backslash
over 2} 
\backslash
rfloor}$
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$x==$ a[mid]} 
\backslash
Return mid
\end_layout

\begin_layout Plain Layout

		
\backslash
ElsIf{$x<$ a[mid]} 
\backslash
Return 
\backslash
Call{Binary-Search}{$a,l,$mid$-1,x$}
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: 
\backslash
Return 
\backslash
Call{Binary-Search}{$a,$mid$+1,r,x$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similarly, until we find 
\begin_inset Formula $x$
\end_inset

, at each step we reject half of the input we have, and so at the end we
 must get 
\begin_inset Formula $x$
\end_inset

 or our search must end in vain.
 The recurrence relation is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
T(1) & n=1\\
T(n/2)+c & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where the constant work is accounted for by 
\begin_inset Formula $c$
\end_inset

, hence by substitution,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & T(n/2)+c\\
 & = & T(n/4)+2c\\
 & = & T(n/8)+3c\\
 & \vdots\\
 & = & T(n/2^{k})+kc\\
 & = & T(1)+c\cdot\log_{2}n=O(\log n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Hence, the time complexity of binary search is logarithmic.
\end_layout

\begin_layout Section
Maximum or Minimum in a List
\end_layout

\begin_layout Standard
We are given a list 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 values and we need to find the maximum or minimum value in it (suppose
 we want both the values).
 What is the best possible way?
\end_layout

\begin_layout Subsection
Straightforward Approach
\end_layout

\begin_layout Standard
A simple straightforward approach goes through the list linearly and records
 at each step the maximum and minimum values.
 This approach takes 
\begin_inset Formula $O(n)$
\end_inset

 time at worst.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Straightforward Maximum Minimum}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Straightforward-Max-Min}{$a,n,$max$,$min}
\end_layout

\begin_layout Plain Layout

	
\backslash
State max = min = a[1]
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=2$ 
\backslash
textbf{to} $n$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]>$max} 
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]<$min} 
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Line 
\begin_inset Formula $2$
\end_inset

 runs for 
\begin_inset Formula $1$
\end_inset

 time, Line 
\begin_inset Formula $3$
\end_inset

 runs for 
\begin_inset Formula $n$
\end_inset

 times, and so does each of the statement inside for 
\begin_inset Formula $n-1$
\end_inset

 times, upto line 
\begin_inset Formula $9$
\end_inset

.
 Hence, 
\begin_inset Formula 
\[
T(n)=1+n+7(n-1)=8n-6=O(n)
\]

\end_inset


\end_layout

\begin_layout Subsection
Finding maximum-minimum using Divide and Conquer
\end_layout

\begin_layout Standard
We can reduce the number of instructions executed if we use divide and conquer.
 So, in this strategy, let us divide the input 
\begin_inset Formula $a[i:j]$
\end_inset

 into some parts (say halves), and find out their maximum and minimum using
 the same strategy (let them be max
\begin_inset Formula $_{1}$
\end_inset

, max
\begin_inset Formula $_{2}$
\end_inset

 and min
\begin_inset Formula $_{1}$
\end_inset

, min
\begin_inset Formula $_{2}$
\end_inset

).
 Then the maximum and minimum of entire input can be found out as 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mbox{max} & = & \mbox{maximum}(\mbox{max}_{1},\mbox{max}_{2})\\
\mbox{min} & = & \mbox{minimum}(\mbox{min}_{1},\mbox{min}_{2})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Maximum Minimum using Divide and Conquer}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Max-Min}{$a, i, j,$ max$,$ min}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$i==j$} max = min = $a[i]$
\end_layout

\begin_layout Plain Layout

	
\backslash
ElsIf{$i==j-1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]<a[j]$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[j]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[i]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[j]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State mid = $
\backslash
displaystyle{
\backslash
lfloor 
\backslash
frac{i+j}{2} 
\backslash
rfloor}$
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Max-Min}{$a, i,$ mid$,$ max$_1,$ min$_1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Max-Min}{$a,$ mid$+1,j,$ max$_2, $ min$_2$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{max$_1<$ max$_2$} max = max$_2$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: max = max$_1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
If{min$_1 < $ min$_2$} min = min$_1$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: min = min$_2$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The procedure is initially invoked using
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Call{Max-Min}{$a,1,n,x,y$}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and the values of maximum and minimum get stored into 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 The instruction count for the steps taking constant time, when taken, give
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
T(\lceil n/2\rceil)+T(\lfloor n/2\rfloor+9 & n>2\\
6 & n=2\\
1 & n=1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
So, for the case when 
\begin_inset Formula $n=2^{k}$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & 2T(n/2)+9\\
 & = & 2\{2T(n/4)+9\}+9\\
 & = & 2^{2}T(n/4)+9(1+2)\\
 & = & 2^{3}T(n/8)+9(1+2+2^{2})\\
 & \vdots\\
 & = & 2^{i}T(n/2^{i})+9(2^{i}-1)\\
 & = & 2^{k-1}T(2)+9(2^{k-1}-1)\\
 & = & 2^{k-1}(6+9)-9\\
 & = & 7.5n-9=O(n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Note that the constant however in the worst case, is 
\begin_inset Formula $7.5$
\end_inset

 compared to 
\begin_inset Formula $8$
\end_inset

 in the straightforward way.
 But this method is not preferred in practice, because it uses too much
 recursion stack space (space complexity) than the simple straightforward
 way.
\end_layout

\begin_layout Section
Merge Sort
\end_layout

\begin_layout Standard
Merge sort is an algorithm to sort a given list 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 elements in 
\begin_inset Formula $O(n\lg n)$
\end_inset

 time.
 It follows the divide and conquer paradigm.
 The basic idea is to divide the list into two halves, sort them recursively
 and combine the results.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Merge Sort}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Merge-Sort}{$a,$ low, high}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{low < high}
\end_layout

\begin_layout Plain Layout

		
\backslash
State mid = $
\backslash
displaystyle{
\backslash
lfloor 
\backslash
frac{
\backslash
mbox{low+high}}{2} 
\backslash
rfloor}$
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Merge-Sort}{$a,$ low, mid}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Merge-Sort}{$a,$ mid$+1,$ high}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Merge}{$a,$ low, mid, high}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The merge subroutine receives two sorted lists 
\begin_inset Formula $a[\mbox{low}:\mbox{mid}]$
\end_inset

 and 
\begin_inset Formula $a[\mbox{mid+1}:\mbox{high}]$
\end_inset

.
 It browses through both the lists and merges them, taking one element at
 a time from any one of the lists, whichever is smaller.
 At the end, we get a sorted list in 
\begin_inset Formula $O(n)$
\end_inset

 time.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Merge}
\backslash
Comment{$b$ is a global array in which the result is stored temporarily.}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Merge}{$a,$ low, mid, high}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $h$ = low
\end_layout

\begin_layout Plain Layout

	
\backslash
State $i$ = low
\end_layout

\begin_layout Plain Layout

	
\backslash
State $j$ = mid+1
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$h 
\backslash
leq$ mid 
\backslash
textbf{and} $j 
\backslash
leq$ high}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[h] 
\backslash
leq a[j]$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $b[i]=a[h]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $h=h+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State $b[i]=a[j]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $j=j+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$h>$ mid}
\end_layout

\begin_layout Plain Layout

		
\backslash
For{$k=j$ 
\backslash
textbf{to} high}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $b[i]=a[k]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $i=i+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
For{$k=h$ 
\backslash
textbf{to} mid}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $b[i]=a[k]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $i=i+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$k$ = low 
\backslash
textbf{to} high}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $a[k]=b[k]$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of 
\series bold
merge
\series default
 is 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(n)=3+4\cdot\max(\lfloor n/2\rfloor,\lceil n/2\rceil)+n
\]

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $n=2^{k}$
\end_inset

,
\begin_inset Formula 
\[
f(n)=3+2n+n=3+3n
\]

\end_inset


\end_layout

\begin_layout Standard
So the time complexity of 
\series bold
merge-sort
\series default
 is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
1 & n=1\\
T(\lceil n/2\rceil)+T(\lfloor n/2\rfloor)+f(n)+2 & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
1 & n=1\\
2T(n/2)+3n+5 & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Using substitution for 
\begin_inset Formula $n>1$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & 2T(n/2)+3n+5\\
 & = & 2(2T(n/4)+3n/2+5)+3n+5\\
 & = & 2^{2}T(n/4)+3n(1+1)+5(1+2)\\
 & = & 2^{2}(2T(n/8)+3n/4+5)+3n(1+1)+5(1+2)\\
 & = & 2^{3}T(n/8)+3n(3)+5(1+2+2^{2})\\
 & \vdots\\
 & = & 2^{i}T(n/2^{i})+3ni+5(2^{i}-1)\\
 & = & 2^{k}T(n/2^{k})+3nk+5(2^{k}-1)\\
 & = & nT(1)+3n\lg n+5(n-1)\\
 & = & 3n\lg n+6n-5=O(n\lg n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
Quick Sort
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Hoare's Partition}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Partition}{$a,l,r$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $v=a[l]$
\backslash
Comment{$v$ is the pivot element}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $i=m$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $j=p$
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$i<j$}
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$a[i]<v$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $i=i+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$a[j] 
\backslash
geq v$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $j=j+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$i<j$} 
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
textbf{swap} $a[i] 
\backslash
leftrightarrow a[j]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

	
\backslash
State $a[m]=a[j]$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $a[j]=v$
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Return $j$
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This sort is more efficient than merge sort.
 Here the list 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 elements is divided in such a way that no merging is later needed.
 Here we partition the list into two halves about a pivot element so that
 all the elements greater than the pivot lie on the right side of it and
 those less than the pivot lie on its left side.
\end_layout

\begin_layout Standard
There are two versions of 
\series bold
partition
\series default
 available - 
\end_layout

\begin_layout Itemize
Hoare's 
\series bold
partition
\series default
, the original 
\series bold
partition 
\series default
procedure
\end_layout

\begin_layout Itemize
Lomuto's 
\series bold
partition
\series default
, the newer (and easier) 
\series bold
partition
\series default
 procedure
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Quick Sort}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Quick-Sort}{$a,p,q$}
\backslash
Comment{Need to sort $a[p:q]$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$p<q$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $j =$ 
\backslash
Call{Partition}{$a,p,q+1$}
\backslash
Comment{$a[j]$ is the pivot}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Quick-Sort}{$a,p,j-1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Quick-Sort}{$a,j+1,q$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Comment{No need for combining solutions.}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Time Complexity
\end_layout

\begin_layout Standard
Suppose we choose a pivot 
\begin_inset Formula $a[j]$
\end_inset

 such that the list 
\begin_inset Formula $a[p:q]$
\end_inset

 is divided into size 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $n-k$
\end_inset

 where 
\begin_inset Formula $n=q-p+1$
\end_inset

.
 Then, because the 
\series bold
partition 
\series default
algorithm takes at most 
\begin_inset Formula $O(n)$
\end_inset

 comparisons, we can say it did 
\begin_inset Formula $\alpha n$
\end_inset

 comparisons where 
\begin_inset Formula $0\leq\alpha\leq1$
\end_inset

.
 Hence
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=T(k)+T(n-k)+\alpha n
\]

\end_inset


\end_layout

\begin_layout Subsection*
Worst Case Analysis
\end_layout

\begin_layout Standard
The quick sort algorithm recursion tree depends on the choice of pivot chosen.
 In the worst case, this tree will have the largest depth, so, at each step
 
\begin_inset Formula $a[p:q]$
\end_inset

 is at least divided into sizes 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n-1$
\end_inset

.
 Hence
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & \leq & T(1)+T(n-1)+\alpha n\\
 & = & T(1)+(T(1)+T(n-2)+\alpha(n-1))+\alpha n\\
 & = & 2T(1)+T(n-2)+\alpha(n+(n-1))\\
 & \vdots\\
 & = & iT(1)+T(n-i)+\alpha(n+(n-1)+\dotsb+(n-i+1))\\
 & = & (n-1)T(1)+T(1)+\alpha(1+2+\dotsb+(n-1))\\
 & = & nT(1)+\frac{\alpha n(n-1)}{2}=O(n^{2})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection*
Best Case Analysis
\end_layout

\begin_layout Standard
In the best case, the recursion tree has the smallest size, so here at each
 step, it can be thought of as being divided into sizes 
\begin_inset Formula $n/2$
\end_inset

 each.
 Then,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & 2T(n/2)+\alpha n\\
 & = & 2(2T(n/4)+\alpha n/2)+\alpha n\\
 & = & 2^{2}T(n/4)+2\alpha n\\
 & \vdots\\
 & = & 2^{i}T(n/2^{i})+i\alpha n\\
 & = & 2^{k}T(n/2^{k})+k\alpha n\\
 & = & nT(n/n)+\alpha n\lg n\\
 & = & nT(1)+\alpha n\lg n=O(n\lg n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection*
Average Case
\end_layout

\begin_layout Standard
In the average case, we need to find the average value of 
\begin_inset Formula $T(n)$
\end_inset

 over all 
\begin_inset Formula $k$
\end_inset

.
 Ideally it should be between the best case and worst case.
 Using the notation 
\begin_inset Formula $T(1:k)=T(1)+T(2)+\dotsb+T(k)$
\end_inset

 and the fact that 
\begin_inset Formula $P(T(k)\mbox{ occurs})={\displaystyle \frac{1}{n-1}}$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mbox{avg }T(n) & = & \mbox{avg }T(k)+\mbox{avg }T(n-k)+\alpha n\\
 & = & {\displaystyle \sum_{k=1}^{n-1}T(k)\cdot P(T(k)}\mbox{ occurs})+{\displaystyle \sum_{k=1}^{n-1}T(n-k)\cdot P(T(n-k)}\mbox{ occurs})+\alpha n\\
 & = & {\displaystyle \frac{2}{n-1}T(1:n-1)}+\alpha n\\
 & = & {\displaystyle \frac{2}{n-1}T(1:n-2)+\frac{2}{n-1}T(n-1)+\alpha n}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Plugging in the values recursively we find
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & {\displaystyle \frac{2}{n-1}T(1:n-2)}+\frac{2}{n-1}\bigg\{\frac{2}{n-2}T(1:n-2)+\alpha(n-1)\bigg\}+\alpha n\\
 & = & {\displaystyle \frac{2}{n-1}T(1:n-2)\bigg\{1+\frac{2}{n-2}\bigg\}}+\alpha n+2\alpha\\
 & = & {\displaystyle \frac{2n}{(n-1)(n-2)}T(1:n-2)+\alpha n+2\alpha}\\
 & = & {\displaystyle \frac{2n}{(n-1)(n-2)}T(1:n-3)+\frac{2n}{(n-1)(n-2)}\bigg\{\frac{2}{n-3}T(1:n-3)+\alpha(n-2)\bigg\}+\alpha n+2\alpha}\\
 & = & {\displaystyle \frac{2n}{(n-1)(n-2)}T(1:n-3)\bigg\{1+\frac{2}{n-3}\bigg\}+\alpha n+2\alpha+2\alpha\frac{n}{n-1}}\\
 & = & \frac{2n}{(n-2)(n-3)}T(1:n-3)+\alpha n+2\alpha n\bigg\{\frac{1}{n}+\frac{1}{n-1}\bigg\}\\
 & \vdots\\
 & = & {\displaystyle \frac{2n}{(n-k)(n-k-1)}T(1:n-k-1)+\alpha n+2\alpha n\bigg\{\frac{1}{n}+\dotsb+\frac{1}{n-k+1}\bigg\}}\\
 & = & {\displaystyle \frac{2n}{2\cdot1}T(1:1)+\alpha n+2\alpha n\bigg\{\frac{1}{n}+\dotsb+\frac{1}{3}\bigg\}}\\
 & = & nT(1)-2\alpha n+2\alpha n{\displaystyle \sum_{i=1}^{n}\frac{1}{i}}\\
 & \leq & nT(1)-2\alpha n+2\alpha n{\displaystyle \int_{1}^{n}\frac{1}{x}dx}\\
 & = & nT(1)-2\alpha n+2\alpha n\ln n=O(n\lg n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection*
Randomized Quick Sort
\end_layout

\begin_layout Standard
We could replace line 
\begin_inset Formula $2$
\end_inset

 in Hoare's 
\series bold
partition
\series default
 algorithm by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v=\mbox{random}(a,l,r)
\]

\end_inset


\end_layout

\begin_layout Standard
where the random function chooses an element in 
\begin_inset Formula $a[l:r]$
\end_inset

 randomly.
 This would create a randomized quick sort algorithm, and on average its
 running time is 
\begin_inset Formula $O(n\lg n)$
\end_inset

.
 It is important to note, that if we choose any pivot on random that splits
 
\begin_inset Formula $a$
\end_inset

 into at least 
\begin_inset Formula $25\%:75\%$
\end_inset

, then it is guaranteed that it would result in 
\begin_inset Formula $O(n\lg n)$
\end_inset

 time.
 This (or a better) split is called a 
\series bold
good split
\series default
.
 In case of randomized algorithm, this split is achieved in most of the
 cases.
\end_layout

\begin_layout Section
The Problem of Selection
\end_layout

\begin_layout Standard
In this problem, we are required to find 
\begin_inset Formula $k$
\end_inset

th smallest element in 
\begin_inset Formula $a[1:n]$
\end_inset

.
 An easy way to do this would be run any sorting algorithm, and then return
 
\begin_inset Formula $a[k]$
\end_inset

.
 But this would take 
\begin_inset Formula $O(n\lg n)$
\end_inset

 time at least.
 Can we do better?
\end_layout

\begin_layout Subsection
Hoare Select
\end_layout

\begin_layout Subsection*
Using Hoare's Partition
\end_layout

\begin_layout Standard
In Hoare's 
\series bold
partition
\series default
, we used to choose a pivot element and divide 
\begin_inset Formula $a$
\end_inset

 into two parts based on the pivot.
 What if the pivot we choose comes out to split 
\begin_inset Formula $a$
\end_inset

 into 
\begin_inset Formula $k-1$
\end_inset

 and 
\begin_inset Formula $n-k$
\end_inset

 elements? Then, the pivot must be the 
\begin_inset Formula $k$
\end_inset

th smallest element.
 This is the main idea.
 We may not be able to find out the suitable pivot for the desired split,
 but we can try again on the reduced 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Hoare's Select}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Hoare-Select}{$a,n,k$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State low = $1$
\end_layout

\begin_layout Plain Layout

	
\backslash
State high = $n$
\end_layout

\begin_layout Plain Layout

	
\backslash
While{(
\backslash
textbf{True})}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $j$ = 
\backslash
Call{Hoare-Partition}{$a$, low, high}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$k==j$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return $a[j]$
\end_layout

\begin_layout Plain Layout

		
\backslash
ElsIf{$k<j$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State high = $j-1$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State low = $j+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Time Complexity of Hoare Select
\end_layout

\begin_layout Standard
In the worst case, it can happen that 
\begin_inset Formula $k=1$
\end_inset

 and we partition in such a way that we just remove the largest element
 from 
\begin_inset Formula $a$
\end_inset

.
 Then it would take 
\begin_inset Formula $n$
\end_inset

 iterations of the 
\series bold
while 
\series default
loop, and each iteration runs an instance of 
\series bold
Hoare Select
\series default
, so worst case 
\begin_inset Formula $T(n)=n\cdot O(n)=O(n^{2})$
\end_inset

.
 In the average case, we can say
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & (\mbox{work done in \textbf{partition}})+(\mbox{average work done due to pivot chosen})\\
 & = & O(n)+\mbox{average}((\mbox{case }k=j)\mbox{ or }(\mbox{case }k<j)\mbox{ or }(\mbox{case }k>j))\\
 & = & O(n)+{\displaystyle \frac{1}{n}\sum_{j=1}^{n}\bigg\{ P(k=j)\cdot d+P(k<j)\cdot T(j-1)+P(k>j)\cdot T(n-j)\bigg\}}\\
 & = & O(n)+{\displaystyle \frac{1}{n}\sum_{j=1}^{n}\bigg\{\frac{1}{n}\cdot d+\frac{j-1}{n}\cdot T(j-1)+\frac{n-j}{n}\cdot T(n-j)\bigg\}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This is because the splits are based on 
\begin_inset Formula $j$
\end_inset

 chosen, and 
\begin_inset Formula $P(k=j)$
\end_inset

 is the probability that we choose the desired item across 
\begin_inset Formula $n$
\end_inset

 items.
 Similarly, 
\begin_inset Formula $P(k<j)$
\end_inset

 is the probability that we choose a pivot 
\begin_inset Formula $a[j]$
\end_inset

 such that it is greater than 
\begin_inset Formula $k$
\end_inset

th smallest element.
 Because for any 
\begin_inset Formula $j$
\end_inset

, 
\begin_inset Formula $k$
\end_inset

 can assume only 
\begin_inset Formula $j-1$
\end_inset

 such values, so 
\begin_inset Formula $P(k<j)$
\end_inset

 is 
\begin_inset Formula $(j-1)/n$
\end_inset

.
 In the same way, 
\begin_inset Formula $P(k>j)=(n-j)/n$
\end_inset

.
 Using the notation 
\begin_inset Formula $t(1:m)=1T(1)+2T(2)+\dotsb+mT(m)$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & \leq & cn+{\displaystyle \frac{1}{n^{2}}\sum_{j=1}^{n}\bigg\{ d+(j-1)\cdot T(j-1)+(n-j)T(n-j)\bigg\}}\\
 & = & cn+{\displaystyle \frac{1}{n^{2}}\bigg\{ dn+2\cdot t(1:n-1)\bigg\}}\\
 & = & cn+{\displaystyle \frac{d}{n}+\frac{2}{n^{2}}t(1:n-1)}\\
 & = & cn+{\displaystyle \frac{d}{n}+\frac{2}{n^{2}}t(1:n-2)+\frac{2}{n^{2}}(n-1)T(n-1)}\\
 & \leq & cn+{\displaystyle \frac{d}{n}+\frac{2}{n^{2}}t(1:n-2)+\frac{2(n-1)}{n^{2}}\bigg\{ c(n-1)+\frac{d}{n-1}+\frac{2}{(n-1)^{2}}t(1:n-2)\bigg\}}\\
 & = & {\displaystyle cn+\frac{2c(n+1)}{n}\bigg\{\frac{(n-1)^{2}}{n(n+1)}\bigg\}+\frac{d}{n}+\frac{2d(n+1)}{n}\bigg\{\frac{1}{n(n+1)}\bigg\}+\frac{2(n+1)}{n}\bigg\{\frac{t(1:n-2)}{n(n-1)}\bigg\}}\\
 & = & cn+{\displaystyle \frac{2c(n+1)}{n}\bigg\{\frac{(n-1)^{2}}{n(n+1)}+\frac{(n-2)^{2}}{(n-1)n}\bigg\}+\frac{d}{n}+\frac{2d(n+1)}{n}\bigg\{\frac{1}{n(n+1)}+\frac{1}{(n-1)n}\bigg\}}\\
 &  & +\frac{2(n+1)}{n}\bigg\{\frac{t(1:n-3)}{(n-1)(n-2)}\bigg\}\\
 & \vdots\\
 & = & cn+{\displaystyle \frac{2c(n+1)}{n}\sum_{i=1}^{k}\frac{(n-i)^{2}}{(n-i+1)(n-i+2)}+\frac{d}{n}+\frac{2d(n+1)}{n}\sum_{i=1}^{k}\frac{1}{(n-i+1)(n-i+2)}}\\
 &  & {\displaystyle +\frac{2(n+1)}{n}\bigg\{\frac{t(1:n-k-1)}{(n-k+1)(n-k)}\bigg\}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Using 
\begin_inset Formula $k=n-2$
\end_inset

 and 
\begin_inset Formula $T(1)=1T(1)=t(1:1)=e$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & cn+{\displaystyle \frac{2c(n+1)}{n}\sum_{i=1}^{n-2}\frac{(n-i)^{2}}{(n-i+1)(n-i+2)}+\frac{d}{n}+\frac{2d(n+1)}{n}\sum_{i=1}^{n-2}\frac{1}{(n-i+1)(n-i+2)}}\\
 &  & {\displaystyle +\frac{2(n+1)}{n}\bigg\{\frac{t(1:1)}{3\cdot2}\bigg\}}\\
 & = & {\displaystyle cn+\frac{2c(n+1)}{n}\sum_{i=1}^{n-2}\bigg\{1-\frac{1}{n-i+1}-\frac{2}{n-i+2}+\frac{2}{(n-i+1)(n-i+2)}\bigg\}}\\
 &  & {\displaystyle +\frac{2d(n+1)}{n}\sum_{i=1}^{n-2}\frac{1}{(n-i+1)(n-i+2)}+\frac{(n+1)e}{3n}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & cn+{\displaystyle \frac{2c(n+1)}{n}\bigg\{(n-2)-\bigg(\frac{1}{3}+\dotsb+\frac{1}{n}\bigg)-2\bigg(\frac{1}{4}+\dotsb+\frac{1}{n+1}\bigg)\bigg\}}\\
 &  & {\displaystyle +\frac{2(n+1)(2c+d)}{n}\sum_{i=1}^{n-2}\frac{1}{(n-i+1)(n-i+2)}+\frac{(n+1)e}{3n}}\\
 & = & cn+{\displaystyle \frac{2c(n+1)}{n}\bigg\{(n-2)-\ln n-2\ln(n+1)+\bigg(1\cdot3+\frac{1}{2}\cdot3+\frac{1}{3}\cdot2+\frac{1}{4}\cdot2\bigg)\bigg\}}\\
 &  & {\displaystyle \frac{2(n+1)(2c+d)}{n}\bigg\{\frac{1}{3}-\frac{1}{n+1}\bigg\}+\frac{(n+1)e}{3n}=O(n)}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
So, on average, 
\series bold
Hoare Select
\series default
 (also 
\series bold
quickselect
\series default
) takes 
\begin_inset Formula $O(n)$
\end_inset

 time.
\end_layout

\begin_layout Subsection
Selection Using Median of Medians
\end_layout

\begin_layout Standard
In this technique, we divide the list 
\begin_inset Formula $a$
\end_inset

 of size 
\begin_inset Formula $n$
\end_inset

 into 
\begin_inset Formula $g=\lfloor n/r\rfloor$
\end_inset

 groups of 
\begin_inset Formula $r$
\end_inset

 elements each, leaving the extra elements.
 For each of these groups we find the medians, say 
\begin_inset Formula $m[1:g]$
\end_inset

 and then we find the median of these medians.
 Then we do the usual selection by partitioning about this median of medians
 as pivot.
 In this way, we are guaranteed to have better than 
\begin_inset Formula $25\%:75\%$
\end_inset

 split, thus we get a worst case 
\begin_inset Formula $O(n)$
\end_inset

 time complexity.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Selection Using Median of Medians}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Median-of-Medians-Select}{$a,k,$ low, high}
\end_layout

\begin_layout Plain Layout

	
\backslash
While{
\backslash
textbf{True}}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $n$ = high-low$+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$n 
\backslash
leq r$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Call{Sort}{$a,$ low, high}
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return $a[k]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
For{$i=1$ 
\backslash
textbf{to} $
\backslash
lfloor n/r 
\backslash
rfloor$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $m[i]$ = 
\backslash
Call{Median}{$a,$ low$+ri-r,$ low+$ri-1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
State $v$ = 
\backslash
Call{Median-of-Medians-Select}{$m,
\backslash
lfloor 
\backslash
lfloor n/r 
\backslash
rfloor /2 
\backslash
rfloor,1,
\backslash
lfloor n/r 
\backslash
rfloor$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $j$ = 
\backslash
Call{Hoare-Partition}{$a$, low, high}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$k==j$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return $a[j]$
\end_layout

\begin_layout Plain Layout

		
\backslash
ElsIf{$k<j$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State high = $j-1$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State low = $j+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Worst case analysis can be proved using induction.
\end_layout

\begin_layout Problem
Try to do selection using median of medians technique, but with insertion-sort.
 Is the worst case time complexity the same?
\end_layout

\begin_layout Section
Strassen's Matrix Multiplication Algorithm
\end_layout

\begin_layout Standard
Matrix multiplication takes 
\begin_inset Formula $O(n^{3})$
\end_inset

 time.
 If two matrices are multiplied to give a third matrix (representative of
 larger matrices) such that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{pmatrix}a & b\\
c & d
\end{pmatrix}\begin{pmatrix}e & f\\
g & h
\end{pmatrix}=\begin{pmatrix}u & v\\
w & x
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Standard
then,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
u & = & ae+bg\\
v & = & af+bh\\
w & = & ce+dg\\
x & = & cf+gh
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
It takes 
\begin_inset Formula $8$
\end_inset

 multiplications to achieve this result.
 So the time complexity of general matrix multiplication algorithm is 
\begin_inset Formula $T(n)=8T(n/2)+O(n^{2})$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the dimension of the matrices (both 
\begin_inset Formula $n\times n$
\end_inset

 each, without the loss of generality).
 It takes 
\begin_inset Formula $O(n^{2})$
\end_inset

 time to add the results, assuming it takes 
\begin_inset Formula $O(1)$
\end_inset

 time to add.
 Strassen formulated a method of matrix multiplication which reduced the
 time complexity by a fractional power.
 In his version, only 
\begin_inset Formula $7$
\end_inset

 multiplications were needed.
 Let us define some sums - 
\begin_inset Formula 
\begin{eqnarray*}
S_{1} & = & f-h\\
S_{2} & = & a+b\\
S_{3} & = & c+d\\
S_{4} & = & g-e\\
S_{5} & = & a+d\\
S_{6} & = & e+h\\
S_{7} & = & b-d\\
S_{8} & = & g+h\\
S_{9} & = & a-c\\
S_{10} & = & e+f
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Then the 
\begin_inset Formula $7$
\end_inset

 products accordingly, as given by Strassen are - 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
P_{1} & = & a\cdot S_{1}=a(f-h)\\
P_{2} & = & h\cdot S_{2}=h(a+b)\\
P_{3} & = & e\cdot S_{3}=e(c+d)\\
P_{4} & = & d\cdot S_{4}=d(g-e)\\
P_{5} & = & S_{5}\cdot S_{6}=(a+d)(e+h)\\
P_{6} & = & S_{7}\cdot S_{8}=(b-d)(g+h)\\
P_{7} & = & S_{9}\cdot S_{10}=(a-c)(e+f)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Using these products, the terms become
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
u & = & ae+bg=P_{4}+P_{5}+P_{6}-P_{2}\\
v & = & af+bh=P_{1}+P_{2}\\
w & = & ce+dg=P_{3}+P_{4}\\
x & = & cf+dh=P_{1}-P_{3}+P_{5}-P_{7}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The time complexity of matrix multiplication using this scheme becomes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=7T(n/2)+O(n^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
It can be checked by substitution that this recurrence relation gives us
 a time complexity 
\begin_inset Formula $T(n)=O(n^{\lg7})=O(n^{2.807})$
\end_inset

.
 This algorithm holds for non square matrices as well.
 However, Strassen's algorithm is not preferred over the general method.
 This is because the constant 
\begin_inset Formula $c$
\end_inset

 in its worst case time complexity is significantly more than the naive
 multiplication algorithm.
 Moreover, it consumes more space.
\end_layout

\begin_layout Chapter
The Greedy Method
\end_layout

\begin_layout Section
The General Way
\end_layout

\begin_layout Standard
This paradigm is applicable to a large variety of problems.
 Greedy approach requires at each step to find out a temporary output, selected
 via a specific selection procedure, and then process that output into the
 solution set if it is feasible, i.e.
 considering local optimality.
\end_layout

\begin_layout Section
Optimal Storage on Tapes
\end_layout

\begin_layout Standard
Suppose there are 
\begin_inset Formula $n$
\end_inset

 programs which are to be stored on a computer tape of length 
\begin_inset Formula $l$
\end_inset

.
 If the program 
\begin_inset Formula $i$
\end_inset

 has length 
\begin_inset Formula $l_{i}$
\end_inset

, then to store all the programs,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
{\displaystyle \bigg\{\sum_{i=1}^{n}l_{i}\bigg\}\leq l}
\]

\end_inset


\end_layout

\begin_layout Standard
Let us assume that this condition is satisfied.
 Suppose we choose an ordering of the programs (one out of 
\begin_inset Formula $n!$
\end_inset

 orderings).
 We define the time required to access a program at its 
\series bold
retrieval
\series default
 time.
 Then for the program at 
\begin_inset Formula $j$
\end_inset

th position in the ordering (say 
\begin_inset Formula $<a_{1},a_{2},a_{3}\dotsb a_{n}>$
\end_inset

 where 
\begin_inset Formula $a_{i}$
\end_inset

's are 
\begin_inset Formula $l_{i}$
\end_inset

's in a jumbled order) is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(j)=a_{1}+a_{2}+\dotsb+a_{j}
\]

\end_inset


\end_layout

\begin_layout Standard
The problem is to choose an ordering such that the 
\series bold
mean retrieval time 
\series default
(MRT) is minimized.
 MRT can be defined as the mean of all the retreival times.
 So,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mbox{MRT}={\displaystyle \frac{1}{n}\bigg\{ T(1)+T(2)+\dotsb+T(n)\bigg\}}
\]

\end_inset


\end_layout

\begin_layout Subsection*
Solution using Greedy Approach
\end_layout

\begin_layout Standard
Since we need to minimize MRT, one way which would be locally optimal would
 be to maintain a sum of ordering done till that stage, and add that element
 that minimizes the next sum.
 This can be implemented simply in 
\begin_inset Formula $O(n^{2})$
\end_inset

 time, or using heaps it can be implemented in 
\begin_inset Formula $O(n\lg n)$
\end_inset

 time.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Optimal Storage on Tapes using Heaps}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Optimal-Tape-Storage}{$l,n$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State order = 
\backslash
{
\backslash
}
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=1$ 
\backslash
textbf{to} $n$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Add-to-Heap}{$l[i]$}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=1$ 
\backslash
textbf{to} $n$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State item = 
\backslash
Call{Extract-Min}{}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
textbf{append} item.i 
\backslash
textbf{to} order
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Return order
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, the non decreasing permutation of 
\begin_inset Formula $l$
\end_inset

 is the optimal solution.
 This can be proved by contradiction.
\end_layout

\begin_layout Section
Job Sequencing with Deadlines
\end_layout

\begin_layout Standard
We are given a set of 
\begin_inset Formula $n$
\end_inset

 jobs.
 For any job 
\begin_inset Formula $i$
\end_inset

, we are given its deadline 
\begin_inset Formula $d_{i}$
\end_inset

 and profit 
\begin_inset Formula $p_{i}$
\end_inset

.
 If the job is completed by its deadline, then 
\begin_inset Formula $p_{i}$
\end_inset

 is earned.
 To complete a job, it has to be processed for unit time.
 A 
\series bold
feasible
\series default
 solution is a subset of the jobs, such that in this subset all the jobs
 are completed before time.
 The feasible solution with the maximum total profit is called the 
\series bold
optimal
\series default
 solution.
 Suppose the subset is 
\begin_inset Formula $J$
\end_inset

.
 Then the total profit 
\begin_inset Formula $P$
\end_inset

 is 
\begin_inset Formula 
\[
P={\displaystyle \sum_{i\in J}p_{i}}
\]

\end_inset


\end_layout

\begin_layout Subsection*
The Greedy Way
\end_layout

\begin_layout Standard
Because we have to maximise 
\begin_inset Formula $P$
\end_inset

, we choose the next job such that it maximizes the new 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Job Sequencing with Deadlines}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Job-Sequencing}{$n,J,D$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Jobs $1 
\backslash
dotsb n$ are ordered in non increasing order of $P$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $J[0]=0$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $D[J[0]]=0$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $J[1]=1$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $k=1$
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=2$ 
\backslash
textbf{to} $n$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $r=k$
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$D[J[r]] > D[i]$ 
\backslash
textbf{and} $D[J[r]] 
\backslash
neq r$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $r=r-1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$D[J[r]] 
\backslash
leq D[i]$ 
\backslash
textbf{and} $D[i] > r$}
\end_layout

\begin_layout Plain Layout

			
\backslash
For{$q=k$ 
\backslash
textbf{to} $r-1$ 
\backslash
textbf{step} $-1$}
\end_layout

\begin_layout Plain Layout

				
\backslash
State $J[q-1]=J[q]$
\end_layout

\begin_layout Plain Layout

			
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

			
\backslash
State $J[r+1]=i$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $k=k+1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Time Complexity
\end_layout

\begin_layout Standard
Outer for loop takes 
\begin_inset Formula $O(n)$
\end_inset

 time.
 For each iteration, the while loop takes 
\begin_inset Formula $O(k)$
\end_inset

 time and if the 
\series bold
if 
\series default
block is executed then it takes 
\begin_inset Formula $O(k-r)=O(k)$
\end_inset

 time to insert a job into the solution.
 Hence the total time complexity should be 
\begin_inset Formula $O(n)\cdot O(k)=O(nk)$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 is the number of jobs in the final solution.
 Because 
\begin_inset Formula $k\leq n$
\end_inset

, so 
\begin_inset Formula $k=O(n)$
\end_inset

.
 Hence for this version of job sequencing, the time complexity is 
\begin_inset Formula $O(n^{2})$
\end_inset

.
\end_layout

\begin_layout Subsection*
Faster Job Scheduling
\end_layout

\begin_layout Standard
Another way to implement the same idea would be to use disjoint sets data
 structure, which allows for 
\series bold
collapse-find
\series default
 and 
\series bold
union
\series default
 operations.
 In that way, the time complexity reduces to 
\begin_inset Formula $O(n\alpha(2n,n))$
\end_inset

 where 
\begin_inset Formula $\alpha$
\end_inset

 signifies the inverse Ackermann function.
 So, the time compexity is near linear.
\end_layout

\begin_layout Section
Optimal Merge Patterns
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
