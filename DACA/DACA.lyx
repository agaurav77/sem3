#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{algorithm}
\usepackage{algpseudocode}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Analysis of Computer Algorithms
\end_layout

\begin_layout Chapter
Basic Tools on Designing Algorithms
\end_layout

\begin_layout Section
Algorithms
\end_layout

\begin_layout Standard
An algorithm is a finite set of instructions that when followed on certain
 set of values (the input), halts to produce a desired set of values (the
 output).
 All algorithms follow some criteria - 
\end_layout

\begin_layout Itemize
It should have an input set (zero or more values)
\end_layout

\begin_layout Itemize
It should have an output set (one or more values)
\end_layout

\begin_layout Itemize
Each instruction has to be precisely clear.
 No ambiguity.
\end_layout

\begin_layout Itemize
The algorithm should stop after a finite number of steps.
\end_layout

\begin_layout Itemize
The steps should be simple enough.
\end_layout

\begin_layout Subsection
Computational Procedure
\end_layout

\begin_layout Standard
A finite set of instructions that is clear and simple/effective (follows
 
\begin_inset Formula $3,5$
\end_inset

) but which might/might not stop after a finite number of steps is a computation
al procedure.
 An example is a bash console, or an operating system.
\end_layout

\begin_layout Subsection
Program
\end_layout

\begin_layout Standard
What is a program? It is just the algorithm, written in a programming language
 which has a specific syntax.
\end_layout

\begin_layout Section
Algorithm Specification
\end_layout

\begin_layout Standard
An algorithm can be described in multiple ways.
 We can use a natural language like English, or we could use a real programming
 language like Python or C.
 However, what is generally preferred is a mix of the two.
 We call this convention 
\series bold
pseudocode
\series default
.
 Pseudocode is just like writing English, except the fact that instructions
 are quite precise and definite.
 Some functions or keywords like 
\series bold
while
\series default
, 
\series bold
for
\series default
 etc.
 are directly borrowed from simple programming languages so that the reader
 is at ease with whatever he/she knows about programming languages, and
 doesn't need to learn something new to learn algorithms.
\end_layout

\begin_layout Enumerate
Comments are written down as
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Comment{This is where the comment occurs.}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Variable assignment is done as
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $x=5$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In general, the common relational operators are
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $x==5$ 
\backslash
Comment{Is $x$ equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x>5$ 
\backslash
Comment{Is $x$ greater than $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x<5$ 
\backslash
Comment{Is $x$ less than $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x>=5$ 
\backslash
Comment{Is $x$ greater than or equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x<=5$ 
\backslash
Comment{Is $x$ less than or equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
State $x
\backslash
neq 5$ 
\backslash
Comment{Is $x$ not equal to $5$?}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The answers to these relational operators are boolean, i.e.
 they can be either true or false.
 We will show a true value by 
\series bold
True
\series default
 and a false value by 
\series bold
False
\series default
.
\end_layout

\end_deeper
\begin_layout Enumerate
The logical operators 
\series bold
and
\series default
, 
\series bold
or
\series default
, 
\series bold
not
\series default
 and their derivatives are used as such.
\end_layout

\begin_layout Enumerate
Most of the loops are either 
\series bold
for
\series default
 or 
\series bold
while
\series default
 in nature.
\end_layout

\begin_layout Enumerate

\series bold
for
\series default
 loops use the following syntax - (Its similar to VB)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
For{$i=$ start 
\backslash
textbf{to} end 
\backslash
textbf{step} $1$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State statement(s)
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
while 
\series default
loops use the following syntax -
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
While{condition}
\end_layout

\begin_layout Plain Layout

	
\backslash
State statement(s)
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Performance Analysis
\end_layout

\begin_layout Subsection
Space Complexity
\end_layout

\begin_layout Standard
This is the amount of memory an algorithm needs to halt and produce a correct
 output.
\end_layout

\begin_layout Subsection
Time Complexity
\end_layout

\begin_layout Standard
This is the amount of time an algorithm requires to complete.
\end_layout

\begin_layout Subsection
Types of Analysis
\end_layout

\begin_layout Standard
Broadly, performance analysis can be divided into two parts - 
\end_layout

\begin_layout Itemize
Apriori, theoretical estimates
\end_layout

\begin_layout Itemize
Posteriori, practical analysis
\end_layout

\begin_layout Subsection*
Apriori Analysis
\end_layout

\begin_layout Standard
In apriori analysis, we are given the input i.e.
 as set of numbers and we estimate the time or space complexity in terms
 of the input.
 For example, let us find out the time complexity of the following algorithm
 which just adds all the numbers from 
\begin_inset Formula $1$
\end_inset

 to the input.
 Let the input be 
\begin_inset Formula $n$
\end_inset

, then a way to find the time complexity is to actually find the number
 of instructions executed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 
\backslash
caption{Sum of numbers from $1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{sum-upto-n}{$n$}%1
\end_layout

\begin_layout Plain Layout

	
\backslash
State sum = $0$%2
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=1$ to $n$}%3
\end_layout

\begin_layout Plain Layout

		
\backslash
State sum = sum + $i$%4
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor%5
\end_layout

\begin_layout Plain Layout

	
\backslash
State
\backslash
textbf{return} sum%6
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure%7
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Step 
\begin_inset Formula $2$
\end_inset

 takes 
\begin_inset Formula $1$
\end_inset

 instruction, step 
\begin_inset Formula $3$
\end_inset

 runs for 
\begin_inset Formula $n+1$
\end_inset

 instructions because the 
\series bold
for
\series default
 loop starts at 
\begin_inset Formula $i=1$
\end_inset

 and goes on till 
\begin_inset Formula $i=n$
\end_inset

, but in the next iteration finds out that 
\begin_inset Formula $i=n+1$
\end_inset

 which was not intended.
 Every 
\series bold
for 
\series default
loop is like that in real programming languages.
 Similarly step 
\begin_inset Formula $4$
\end_inset

 and 
\begin_inset Formula $5$
\end_inset

 run for 
\begin_inset Formula $n$
\end_inset

 times, and step 
\begin_inset Formula $6$
\end_inset

 takes 
\begin_inset Formula $1$
\end_inset

 instruction.
 So total number of instructions, say 
\begin_inset Formula $T(n)$
\end_inset

 is 
\begin_inset Formula 
\[
T(n)=1+(n+1)+2n+1=3n+3
\]

\end_inset


\end_layout

\begin_layout Standard
So, number of instructions is linear in terms of input.
\end_layout

\begin_layout Quote
In general, apriori analysis of time complexity means finding out the instructio
n count, since that is the same for every machine the algorithm runs on,
 and is a valid theoretical estimate of the actual running time.
\end_layout

\begin_layout Standard
For doing apriori analysis of space complexity, if the data used in the
 algorithm is all of the same type, i.e.
 all numbers or all characters etc., then we find out the capacity of the
 variables used.
 That is the general idea.
\end_layout

\begin_layout Subsection*
Priori Analysis
\end_layout

\begin_layout Standard
It refers to the actual practical running time for the given algorithm,
 and it strictly depends on the system.
 Better systems mean lesser running times and vice versa holds.
\end_layout

\begin_layout Subsection
Asymptotic Notations
\end_layout

\begin_layout Standard
These are the notations which allow us to make meaningful approximations
 about the behavior of an algorithm, i.e.
 how much time it might take and how much space it might take.
 Since these are theoretical notations, they are used to analyse mathematically
 the time and space needed by an algorithm, and hence are useful for apriori
 analysis.
\end_layout

\begin_layout Standard
There is a reason why these notations are called 
\series bold
asymptotic
\series default
.
 This is because the calculations done using these notations represent how
 the actual algorithm behaves for large inputs, even though it may not be
 feasible to run for these large inputs.
 Let us mathematically see these notations -
\end_layout

\begin_layout Subsubsection
Big Oh (
\begin_inset Formula $O$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=O(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(n)\leq c\cdot g(n)\mbox{ for all \ensuremath{n,n\geq n_{0}}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=O(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Big Omega (
\begin_inset Formula $\Omega$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\Omega(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $n_{0}$
\end_inset

 such that 
\begin_inset Formula 
\[
f(n)\geq c\cdot g(n)\mbox{ for all \ensuremath{n,n\geq n_{0}}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=\Omega(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Big Theta (
\begin_inset Formula $\Theta$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\Theta(g(n))$
\end_inset

 if and only if there exist positive constants 
\begin_inset Formula $c_{1},c_{2},n_{0}$
\end_inset

 such that 
\begin_inset Formula 
\[
c_{1}g(n)\leq f(n)\leq c_{2}g(n)\mbox{ for all \ensuremath{n,n\geq0}}
\]

\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $f(n)=O(g(n))$
\end_inset

 and 
\begin_inset Formula $f(n)=\Omega(g(n))$
\end_inset

 then 
\begin_inset Formula $f(n)=\Theta(g(n))$
\end_inset

.
\end_layout

\begin_layout Corollary
If 
\begin_inset Formula $f(n)=a_{m}n^{m}+\cdot\cdot\cdot+a_{1}n+a_{0}$
\end_inset

, then 
\begin_inset Formula $f(n)=\Theta(n^{m})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Little Oh (
\begin_inset Formula $o$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=o(g(n))$
\end_inset

 if and only if 
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}=0
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Little Omega (
\begin_inset Formula $\omega$
\end_inset

) Notation
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $f(n)=\omega(g(n))$
\end_inset

 if and only if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lim_{n\rightarrow\infty}\frac{g(n)}{f(n)}=0
\]

\end_inset


\end_layout

\begin_layout Section
Randomized Algorithms
\end_layout

\begin_layout Subsection
Basics
\end_layout

\begin_layout Standard
In probability, we conduct experiments and analyze their outcomes.
 An 
\series bold
experiment 
\series default
is a procedure that has some definite outcomes, or
\series bold
 events
\series default
.
 For example, tossing a coin is an experiment whose outcomes are either
 heads, or tails.
 Each possible outcome is called a 
\series bold
sample point
\series default
.
 Sample points constitute the 
\series bold
sample space
\series default
, which is simply the set of all possible outcomes for the given experiment,
 whether discrete or continuous.
\end_layout

\begin_layout Subsubsection*
What is probability?
\end_layout

\begin_layout Standard
Suppose the sample space of an event/experiment 
\begin_inset Formula $E$
\end_inset

 is denoted by 
\begin_inset Formula $S$
\end_inset

.
 Then if any outcome is the event 
\begin_inset Formula $X$
\end_inset

, then the probability of that outcome 
\begin_inset Formula $X$
\end_inset

 is defined as 
\begin_inset Formula 
\[
P(X)=\frac{n(X)}{n(S)}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $n(X)$
\end_inset

 are the number of elements that correspond to the outcome 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $n(S)$
\end_inset

 are the number of elements that correspond to the sample space (basically
 the size of the sample space).
\end_layout

\begin_layout Standard
Sum of probabilities of all the outcomes is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Conditional Probability
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $E_{1}$
\end_inset

and 
\begin_inset Formula $E_{2}$
\end_inset

 be any two events of an experiment.
 The 
\series bold
conditional probability 
\series default
of 
\begin_inset Formula $E_{1}$
\end_inset

 occurring given 
\begin_inset Formula $E_{2}$
\end_inset

 has occurred is denoted by 
\begin_inset Formula $P(E_{1}|E_{2})$
\end_inset

 and is given as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(E_{1}|E_{2})=\frac{P(E_{1}\cap E_{2})}{P(E_{2})}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Independence
\end_layout

\begin_layout Standard
Two events 
\begin_inset Formula $E_{1}$
\end_inset

and 
\begin_inset Formula $E_{2}$
\end_inset

 are said to be independent if 
\begin_inset Formula $P(E_{1}\cap E_{2})=P(E_{1})\cdot P(E_{2})$
\end_inset

 i.e.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(E_{1}|E_{2})=P(E_{1})
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Random Variable
\end_layout

\begin_layout Standard
A random variable on the sample space 
\begin_inset Formula $S$
\end_inset

 of an experiment is a function that maps 
\begin_inset Formula $S$
\end_inset

 to the set of real numbers.
 Hence, if 
\begin_inset Formula $X$
\end_inset

 is the random variable, then 
\begin_inset Formula $X(s)$
\end_inset

 is the image of 
\begin_inset Formula $s\in S$
\end_inset

 such that 
\begin_inset Formula $X(s)\in\mathbf{R}$
\end_inset

.
 If the range of 
\begin_inset Formula $X$
\end_inset

 is finite and countable, then we say that 
\begin_inset Formula $X$
\end_inset

 is a discrete randome variable.
\end_layout

\begin_layout Subsubsection*
Expected Value
\end_layout

\begin_layout Standard
The expected value or the mean of any random variable 
\begin_inset Formula $X$
\end_inset

 is defined to be
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
E[X]={\displaystyle \sum_{i=1}^{n}}P(s_{i})\cdot X(s_{i})\mbox{ for all \ensuremath{s_{i}\in S}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Probability Distribution
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $X$
\end_inset

 is a discrete random variable such that its range is 
\begin_inset Formula $\{r_{1},r_{2},...,r_{m}\}$
\end_inset

 then the probability distribution of 
\begin_inset Formula $X$
\end_inset

 is the sequence 
\begin_inset Formula $\{P(X=r_{1}),P(X=r_{2}),...,P(X=r_{m})\}$
\end_inset

.
 Sum over the entire distribution is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Binomial Distribution
\end_layout

\begin_layout Standard
A Bernoulli trial is an experiment that has two possible outcomes, i.e.
 success and failure.
 So, if there are 
\begin_inset Formula $n$
\end_inset

 trials, then the sample space has 
\begin_inset Formula $2^{n}$
\end_inset

 sample points.
 Let 
\begin_inset Formula $X$
\end_inset

 be a random variable which is the number of successes in the 
\begin_inset Formula $n$
\end_inset

 trials.
 Then 
\begin_inset Formula 
\[
P(X=i)=\bigg(\begin{array}{c}
n\\
i
\end{array}\bigg)\cdot p^{i}(1-p)^{n-i}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $p$
\end_inset

 is the probability of success.
\end_layout

\begin_layout Standard
It comes out, that the expected value of 
\begin_inset Formula $X$
\end_inset

 is 
\begin_inset Formula $np$
\end_inset

.
\end_layout

\begin_layout Subsection
Description of Randomized Algorithms
\end_layout

\begin_layout Standard
Randomized algorithms have steps that rely on random choices.
 Those choices are generated when the algorithm is running with the help
 of randomizers (like random number generators).
 Randomized algorithms can be of two types -
\end_layout

\begin_layout Enumerate
Monte Carlo type
\end_layout

\begin_layout Enumerate
Las Vegas type
\end_layout

\begin_layout Subsection
Monte Carlo Randomized Algorithms
\end_layout

\begin_layout Standard
Outputs of these algorithms vary for each run, however the run time is nearly
 the same for each run.
\end_layout

\begin_layout Subsection
Las Vegas Randomized Algorithms
\end_layout

\begin_layout Standard
Run time is a random variable that depends on the random choices made during
 execution.
\end_layout

\begin_layout Subsection
Idea
\end_layout

\begin_layout Standard
A randomized algorithm can be seen as a family of algorithms.
 For any input, some of these algorithms may run for longer time or may
 give wrong outputs.
 We design the algorithm, however, such that the fraction of such bad instances
 is very less.
 If we can design the algorithm to have a large fraction of correct instances,
 then we can be sure that in general, any run will give a correct output.
\end_layout

\begin_layout Chapter
Divide and Conquer
\end_layout

\begin_layout Section
General Way
\end_layout

\begin_layout Standard
Divide and Conquer is a problem solving strategy in which we split the inputs
 into 
\begin_inset Formula $k$
\end_inset

 different parts, yielding 
\begin_inset Formula $k$
\end_inset

 subproblems.
 Then each of the subproblem is individually solved, using the general algorithm
 and results are combined together.
 The approach is a bit recursive.
\end_layout

\begin_layout Subsection*
Control Abstraction
\end_layout

\begin_layout Standard
Control Abstraction refers to a procedure whose flow of control is clear
 but whose primary operations are specified by other procedures whose precise
 meanings are left undefined.
 We can write divide and conquer algorithms using control abstractions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/divide-conquer.svg
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Time Complexity
\end_layout

\begin_layout Standard
In general, the time complexity of a divide and conquer algorithm which
 at each step, divides the input 
\begin_inset Formula $n$
\end_inset

 given to it into 
\begin_inset Formula $a$
\end_inset

 parts of size 
\begin_inset Formula $n/b$
\end_inset

 can be suitably written as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
T(1) & n=1\\
aT(n/b)+f(n) & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $a,b$
\end_inset

 are known constants.
 This is a recurrence relation, which can be solved using the substitution
 method (just substitute 
\begin_inset Formula $T(n/b)$
\end_inset

 over and over again until it disappears).
 A rigorous analysis gives us the solution to this relation (master method).
\end_layout

\begin_layout Section
Application to Binary Search
\end_layout

\begin_layout Standard
Consider a list of elements as input, which are already sorted in non decreasing
 order.
 We need to find whether a given element 
\begin_inset Formula $x$
\end_inset

 is present in the list or not.
 A simple way would be to go through the list checking one element at a
 time, until the list is finished.
 However that would take 
\begin_inset Formula $T(n)\leq n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the number of elements, so that is 
\begin_inset Formula $O(n)$
\end_inset

 in nature.
\end_layout

\begin_layout Standard
However, there is another faster way to find out this, exploiting the fact
 that the list is sorted.
 If we start from the middle of the list, (say the middle element is 
\begin_inset Formula $y$
\end_inset

) and compare it to 
\begin_inset Formula $x$
\end_inset

, then
\end_layout

\begin_layout Itemize
\begin_inset Formula $x>y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 lies to the end of list, i.e.
 towards the end with the largest element.
\end_layout

\begin_layout Itemize
\begin_inset Formula $x<y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 lies towards the end with the smallest element.
\end_layout

\begin_layout Itemize
\begin_inset Formula $x=y$
\end_inset

 would mean 
\begin_inset Formula $x$
\end_inset

 is the middle element, so yes, it exists.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Binary Search}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Binary-Search}{$a,l,r,x$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$r==l$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$x==a[l]$} 
\backslash
Return $l$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: 
\backslash
Return $-1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State mid = $
\backslash
displaystyle{
\backslash
lfloor {l+r 
\backslash
over 2} 
\backslash
rfloor}$
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$x==$ a[mid]} 
\backslash
Return mid
\end_layout

\begin_layout Plain Layout

		
\backslash
ElsIf{$x<$ a[mid]} 
\backslash
Return 
\backslash
Call{Binary-Search}{$a,l,$mid$-1,x$}
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: 
\backslash
Return 
\backslash
Call{Binary-Search}{$a,$mid$+1,r,x$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similarly, until we find 
\begin_inset Formula $x$
\end_inset

, at each step we reject half of the input we have, and so at the end we
 must get 
\begin_inset Formula $x$
\end_inset

 or our search must end in vain.
 The recurrence relation is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\begin{cases}
T(1) & n=1\\
T(n/2)+c & n>1
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where the constant work is accounted for by 
\begin_inset Formula $c$
\end_inset

, hence by substitution,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T(n) & = & T(n/2)+c\\
 & = & T(n/4)+2c\\
 & = & T(n/8)+3c\\
 & \vdots\\
 & = & T(n/2^{k})+kc\\
 & = & T(1)+c\cdot\log_{2}n=O(\log n)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Hence, the time complexity of binary search is logarithmic.
\end_layout

\begin_layout Section
Maximum or Minimum in a List
\end_layout

\begin_layout Standard
We are given a list 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 values and we need to find the maximum or minimum value in it (suppose
 we want both the values).
 What is the best possible way?
\end_layout

\begin_layout Subsection
Straightforward Approach
\end_layout

\begin_layout Standard
A simple straightforward approach goes through the list linearly and records
 at each step the maximum and minimum values.
 This approach takes 
\begin_inset Formula $O(n)$
\end_inset

 time at worst.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Straightforward Maximum Minimum}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Straightforward-Max-Min}{$a,n,$max$,$min}
\end_layout

\begin_layout Plain Layout

	
\backslash
State max = min = a[1]
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$i=2$ 
\backslash
textbf{to} $n$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]>$max} 
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]<$min} 
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Line 
\begin_inset Formula $2$
\end_inset

 runs for 
\begin_inset Formula $1$
\end_inset

 time, Line 
\begin_inset Formula $3$
\end_inset

 runs for 
\begin_inset Formula $n$
\end_inset

 times, and so does each of the statement inside for 
\begin_inset Formula $n-1$
\end_inset

 times, upto line 
\begin_inset Formula $9$
\end_inset

.
 Hence, 
\begin_inset Formula 
\[
T(n)=1+n+7(n-1)=8n-6=O(n)
\]

\end_inset


\end_layout

\begin_layout Subsection
Finding maximum-minimum using Divide and Conquer
\end_layout

\begin_layout Standard
We can reduce the number of instructions executed if we use divide and conquer.
 So, in this strategy, let us divide the input 
\begin_inset Formula $a[i:j]$
\end_inset

 into some parts (say halves), and find out their maximum and minimum using
 the same strategy (let them be max
\begin_inset Formula $_{1}$
\end_inset

, max
\begin_inset Formula $_{2}$
\end_inset

 and min
\begin_inset Formula $_{1}$
\end_inset

, min
\begin_inset Formula $_{2}$
\end_inset

).
 Then the maximum and minimum of entire input can be found out as 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mbox{max} & = & \mbox{maximum}(\mbox{max}_{1},\mbox{max}_{2})\\
\mbox{min} & = & \mbox{minimum}(\mbox{min}_{1},\mbox{min}_{2})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
caption{Maximum Minimum using Divide and Conquer}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Max-Min}{$a, i, j,$ max$,$ min}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$i==j$} max = min = $a[i]$
\end_layout

\begin_layout Plain Layout

	
\backslash
ElsIf{$i==j-1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$a[i]<a[j]$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[j]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[i]$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State max = $a[i]$
\end_layout

\begin_layout Plain Layout

			
\backslash
State min = $a[j]$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State mid = $
\backslash
displaystyle{
\backslash
lfloor 
\backslash
frac{i+j}{2} 
\backslash
rfloor}$
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Max-Min}{$a, i,$ mid$,$ max$_1,$ min$_1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{Max-Min}{$a,$ mid$+1,j,$ max$_2, $ min$_2$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{max$_1<$ max$_2$} max = max$_2$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: max = max$_1$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
If{min$_1 < $ min$_2$} min = min$_1$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else 
\backslash
: min = min$_2$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
